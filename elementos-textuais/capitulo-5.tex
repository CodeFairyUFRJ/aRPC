\chapter{Conclusão}

Neste trabalho foi apresentado o aRPC, um \textit{framework} que procura oferecer ergonomia na escrita do código para o desenvolvedor e um bom desempenho de execução, priorizando ambientes de computação de alto desempenho (HPC). Foram também apresentados os seus resultados quando comparado com o gRPC. O projeto do \textit{framework} foi disponibilizado em \url{https://github.com/almeida-raphael/arpc}, o compilador para a IDL proposta é encontrado em \url{https://github.com/almeida-raphael/arpc_code_generator} e por fim, os casos de teste com as lógicas de coleta de métrica e exemplos de implementação podem ser encontrados em \url{https://github.com/almeida-raphael/arpc_examples}.

A proposta do aRPC tem simplicidade como princípio, então, fazendo uso das capacidades presentes no QUIC para a camada de transporte e no Colfer para a serialização, a implementação do aRPC ficou muito enxuta, contando com cerca de 1500 linhas de código, incluindo o \textit{framework} e o compilador. O projeto foi desenvolvido de maneira colaborativa pelos integrantes deste trabalho. Dado os resultados positivos obtidos na comparação com o gRPC e na quantidade total de linhas de código produzida, é possível afirmar que a arquitetura proposta atingiu o princípio de simplicidade desejado.

A obtenção dos resultados necessitou de uma extensa bateria de testes. Entretanto, devido ao longo tempo de execução necessário para avaliar todos os aspectos desejados, e consideração a grande quantidade de métricas requeridas para a validade estatística dos resultados, foi desenvolvido um mecanismo de automação dos testes. Esse mecanismo de testes abstraiu as lógicas de coleta de métricas de maneira genérica entre os exemplos utilizando o aRPC e os utilizando o gRPC. Os testes envolvidos totalizaram por volta de 4900 linhas de código. Entretanto, cabe levantar que ainda há espaço para explorar o aRPC em mais cenários, como para aplicações de IoT, dada a boa resiliência apresentada pelo QUIC em ambientes com elevadas perda de pacotes. Tal aplicação do aRPC para cenários de IoT pode ser considerada para um trabalho futuro.

Quanto a implementação do \textit{framework} algumas dificuldades foram encontradas, podendo-se citar como exemplo o tamanho variável do cabeçalho dos dados serializados pelo Colfer, que ocasionava leituras de dados corrompidos ao deserializar, sendo necessário que fosse introduzido um byte anterior ao cabeçalho discriminando o seu tamanho deserializado.

Nas seções a seguir são descritos os principais aspectos levantados para os blocos lógicos que compõem o aRPC, que são o serializador, o transporte e o próprio \textit{framework} de maneira geral.

\subsection{Serializador}

Simplicidade ímpar e extrema facilidade de uso, somados a uma ótima performance de serialização, demonstraram que utilizar o Colfer como o serializador do aRPC foi uma escolha acertada. O Colfer pode gerar ganhos em termos de \textit{speedup} de 1,4730 a 2,869 e apesar dos dados serializados serem ligeiramente maiores do que os do Protobuffers (de 1.1\% a 1.6\% maiores), isso não chegou a ser prejudicial para a performance do \textit{framework} em geral, tendo em vista que em diversos casos o aRPC obteve desempenho superior ao gRPC, principalmente se tratando de dados heterogêneos ou de estruturas com muitos elementos, conforme visto na Seção \ref{subsubsection:maquinas_pessoais}.

Um estudo posterior pode tentar combinar os benefícios do Colfer com os benefícios do Protobuffers, de maneira a ter uma maior performance de codificação com dados serializados em tamanhos menores. Um exemplo de melhoria para o Protobuffers seria na serialização de números inteiros negativos, onde são usados desnecessariamente 11 bytes como indicado no Capitulo \ref{chp:capitulo4}.

\subsection{Transporte}

Utilizar o QUIC como protocolo da camada de transporte trouxe diversos benefícios para o \textit{framework}, desde a facilidade de implementação, quanto a resiliência para transmissão de dados em cenários com perda de pacotes na rede.

Foi também possível constatar que mesmo transmitindo dados ligeiramente maiores, na faixa de 1,1\% a 1,6\%, por conta da serialização do Colfer, a vazão na transmissão dos dados ainda conseguiu ser superior à vazão do gRPC em diversos casos, implicando em menor tempo total de execução, o que indica uma que a performance do protocolo é maior que a do TCP em sua aplicação no aRPC.

Infelizmente os bons resultados encontrados pelo QUIC no ambiente de máquinas pessoais se comunicando numa LAN fechada não puderam ser replicado num ambiente de nuvem, possivelmente devido a restrições na da taxa de transferência de datagramas UDP impostos pelos provedores desses serviços. Entretanto, esse cenário tem o potencial de melhorar conforme a adoção do QUIC ganha tração e o protocolo se torna mais notório.

Tendo em vista o cenário encontrado ao se utilizar aplicações com o aRPC em ambientes de nuvem, é possível considerar um trabalho futuro realizando novos testes em \textit{clusters} privados que possuam redes com largura de banda elevada, porém sem as restrições impostas para comunicação via datagramas UDP. A fim de entender melhor o desempenho do \textit{framework} em ambientes de nuvem.

Um outro possível trabalho futuro, relacionado com a camada de transporte, é a implementação do protocolo TCP para o aRPC. Isso forneceria mais informações para comparação com o gRPC, uma vez que ambos os \textit{frameworks} estariam utilizando o mesmo protocolo de transporte.


\subsection{Framework}

O aRPC foi comparado principalmente ao gRPC, neste contexto faz sentido explicitar as principais diferenças entre os dois \textit{frameworks}. O gRPC é um framework maduro e completo, com foco em oferecer uma solução de uso geral com bom desempenho. Dessa forma, ele suporta muitas funcionalidades, como: argumentos opcionais, versionamento dos serviços, suporte a resposta de dados em \textit{stream}, balanceamento de carga, etc. O aRPC é um \textit{framework} direcionado a HPC com principio de simplicidade e ergonomia, além de mais simples e imaturo, e possuindo um conjunto de funcionalidades reduzidas, não suportando nada do que foi mencionado anteriormente. Entretanto, com o foco em HPC e uso do QUIC como protocolo base, apresenta maior desempenho para dados grandes, que é característico das cargas de trabalho de HPC, além de ter maior resiliência a instabilidades de conexão.

Em relação às linguagens suportadas, o gRPC tem a vantagem de seu longo tempo de existência e suporte da comunidade de \textit{software} aberto. Nesse sentido, possui vasta compatibilidade, porém, devido a sua proposta de ser um pacote completo, não é tão fácil implementá-lo em outras linguagens quanto o aRPC. Atualmente o aRPC suporta somente o Go, mas, como mencionado anteriormente, a simplicidade deste \textit{framework} proporciona uma enorme vantagem na implementação para novas linguagens que pode eventualmente levá-lo a um suporte mais amplo que o gRPC.

No contexto de dependências, o gRPC é um projeto grande, com muitas linhas de código, junto ao esse tamanho e complexidade, soma-se o número de dependências. O gRPC depende hoje de doze bibliotecas, algumas do próprio Google, assim como outras externas. Por outro lado, o aRPC possui somente uma dependência, visto que a CLI do Colfer é usada exclusivamente na etapa de geração de código, não sendo uma dependência de tempo de execução do \textit{framework}. Por essa razão, hoje o aRPC depende somente somente de uma implementação do QUIC disponível como biblioteca.

Como dito anteriormente, o gRPC é um projeto maduro, com muitos anos de desenvolvimento, muitos colaboradores e pronto para uso em ambientes de produção, já o aRPC por ser muito novo e ainda não testado extensivamente, não é recomendado ainda para uso em ambientes de produção.

Na comparação de desempenho entre gRPC e aRPC, existe também a questão do desempenho abaixo do esperado do aRPC em ambientes de nuvem devido a restrições na taxa de transferência de datagramas UDP impostas pelos provedores. Esse fator faz com que hoje o gRPC tenha desempenho superior nesse cenário, entretanto, como mencionado, existe uma expectativa que essas restrições sejam aliviadas, ou removidas no futuro com o crescimento do QUIC.

Considerando os resultados apresentados no Capítulo \ref{chp:capitulo4}, os objetivos iniciais propostos foram alcançados, o aRPC obteve ganhos de até 7\% em relação ao gRPC. Como foi demonstrado, o aRPC teve desempenho superior ao gRPC de forma consistente para ambos os casos onde a quantidade de dados trafegada era grande o suficiente, situação comum em aplicação em ambientes HPC, e casos com estruturas de dados heterogêneas que melhor representam dados utilizados em situações reais. Tendo em vista a maturidade do gRPC e sua grande adoção no mercado, esses resultados para um protocolo novo em suas versões iniciais são muito motivantes e demonstram grande espaço para crescimento com evoluções futuras. 

O foco deste trabalho se restringiu as premissas básicas do \textit{framework} e sua comparação a uma das referências de mercado no contexto de RPC. Nesse sentido, no contexto de evoluções e trabalhos futuros, fica a recomendação de validação dos resultados e análises do \textit{framework} em redes de alto desempenho com 2.5Gbps, 10Gbps ou maiores larguras de banda. Além disso, como na arquitetura do aRPC foi previsto o conceito de \textbf{channel} para abstrair outros protocolos, outra análise interessante seria o teste do aRPC usando TCP, HTTP/2 e outros protocolos de transporte. Os testes com outros protocolos gerariam dados interessantes a respeito de quanto do desempenho é obtido por cada bloco lógico do aRPC. Por fim, outro teste relevante seria substituir o Colfer como serializador, possibilitando dessa forma validar a contribuição individual de serializadores distintos para o resultado final. Por fim, outra configuração relevante para análise, seria utilizar os diversos modos do Protobuffers para pouca utilização de recursos, geração de dados pequenos, entre outros, afim de gerar resultados comparativos relativos a todos os modos oferecidos pelo gRPC e aRPC.

O uso das tecnologias escolhidas, QUIC e Colfer, mostram que avanços na área de protocolos e bibliotecas para uso em RPC são possíveis. Estudos e implementações de novas técnicas de serialização no contexto de RPC são bem vindos e podem gerar bons resultados, como o exemplo do aRPC evidencia. Dessa forma, esse trabalho termina apontado que mais desenvolvimentos na área são bem vindos, e que a expectativa é que o aRPC fique como estudo de caso para impulsionar mais pesquisas nesse ramo.

% O quanto o aRPC é diferente do gRPC em termos de funcionalidade, características de uso e desempenho? 

% Como os testes realizados comprovam a eficiência do protocolo para uso em HPC?

%É um dos fundamentos do aRPC manter o usuário dentro das características da linguagem que a aplicação está sendo desenvolvida e oferecer mais ergonomia que algumas das soluções disponíveis no mercado.

%O uso da \textbf{Stream} como mecanismo de associação de requisição com resposta dispensa a necessidade do uso de campos de ID no cabeçalho e facilita a implementação do protocolo, gerando um cabeçalho mais enxuto quando comparado ao HPRPC \cite{bagci_lightweight_2016}.

%Como as interfaces foram desenhadas baseadas em conceitos do QUIC, isso facilitou muito sua implementação como \textbf{Channel} inicial disponibilizado no \textit{framework}. Dessa forma, pode-se observar que o código é bastante semântico e curto. 

%A implementação do \textbf{RPC\_Channel} no aRPC parte de interfaces que possibilitam o uso de outro protocolo como base, como HTTP/2 ou TCP, essa implementação foi deixada como recomendação de trabalho futuro para melhor comparação dos protocolos de transporte isoladamente.

%Atualmente a única linguagem suportada é Go, entretanto, como o protocolo é simples, sua portabilidade e funcionamento em conjunto com outras linguagens é de fácil implementação.

% No entanto, a implementação de \textit{channels} para outros protocolos de transporte é de fácil construção, necessitando apenas da implementação das interfaces a seguir: 

%Essas restrições existem para facilitar a implementação do gerador de código e controlador, e por mais que acarretem em menor flexibilidade e funcionalidades quando comparado com outros protocolos RPC de uso geral, é possível que em um trabalho futuro elas possam ser removidas a fim de melhorar a ergonomia do aRPC. 

% dividir a Figura 8 em duas.

% Figura 10 cabeçalho de tamanho variável

%Devido a quantidade de testes executados e o grande número de configurações necessárias, essa tarefa se mostrou desafiadora. Na configuração atual a quantidade de dados que deve ser trocada para garantir validade estatística somado a velocidade das interfaces de rede fez com que os testes tivessem longas durações.

%A partir da análise dos dados coletados acima é possível concluir que, caso a serialização do Colfer seja mais eficiente ou igual ao Protobuffers, o aRPC pode ter um desempenho melhor ou igual ao gRPC. 

%Já para grandes quantidades de elementos as vantagens do aRPC são mais evidentes e nesses casos, mesmo em uma situação de serialização desvantajosa, o aRPC é mais eficiente, atingindo maior vazão.

%Após uma análise, foi possível concluir que isso ocorre devido a uma ineficiência de serialização de valores negativos no Protobuffers.


